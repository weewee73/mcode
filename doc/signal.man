SIGNAL(2)                  Linux Programmer's Manual                 SIGNAL(2)



NAME
       signal - ANSI C signal handling

SYNOPSIS
       #include <signal.h>

       typedef void (*sighandler_t)(int);

       sighandler_t signal(int signum, sighandler_t handler);

DESCRIPTION
       The behavior of signal() varies across Unix versions, and has also var-
       ied historically across different versions of Linux.   Avoid its use:
       use sigaction(2) instead.  See Portability below.

       signal() sets the disposition of the signal signum to handler, which is
       either SIG_IGN, SIG_DFL, or the address of a programmer-defined func-
       tion (a "signal handler").

       If the signal signum is delivered to the process, then one of the fol-
       lowing happens:

       *  If the disposition is set to SIG_IGN, then the signal is ignored.

       *  If the disposition is set to SIG_DFL, then the default action asso-
          ciated with the signal (see signal(7)) occurs.

       *  If the disposition is set to a function, then first either the dis-
          position is reset to SIG_DFL, or the signal is blocked  (see Porta-
          bility below), and then handler is called with argument signum.  If
          invocation of the handler caused the signal to be blocked, then the
          signal is unblocked upon return from the handler.

       The signals SIGKILL and SIGSTOP cannot be caught or ignored.

RETURN VALUE
       signal()  returns the previous value of the signal handler, or SIG_ERR
       on error.

ERRORS
       EINVAL signum is invalid.

CONFORMING TO
       C89, C99, POSIX.1-2001.

NOTES
       The effects of signal() in a multithreaded process are unspecified.

       According to POSIX, the behavior of a process is undefined after it
       ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not generated by
       kill(2) or raise(3).  Integer division by zero has undefined result.
       On some architectures it will generate a SIGFPE signal.  (Also dividing
       the most negative integer by -1 may generate SIGFPE.)   Ignoring this
       signal might lead to an endless loop.

       See sigaction(2)  for details on what happens when SIGCHLD is set to
       SIG_IGN.

       See signal(7) for a list of the async-signal-safe functions that can be
       safely called from inside a signal handler.

       The use of sighandler_t is a GNU extension.  Various versions of libc
       predefine this type;  libc4 and libc5 define SignalHandler;  glibc
       defines sig_t and,  when _GNU_SOURCE is defined, also sighandler_t.
       Without use of such a type, the declaration of signal() is the somewhat
       harder to read:

           void ( *signal(int signum, void (*handler)(int)) ) (int);

   Portability
       The only portable use of signal() is to set a signal's disposition to
       SIG_DFL or SIG_IGN.  The semantics when using signal() to establish a
       signal handler vary across systems (and POSIX.1 explicitly permits this
       variation); do not use it for this purpose.

       POSIX.1 solved the portability mess by specifying sigaction(2),  which
       provides explicit control of the semantics when a signal handler is
       invoked; use that interface instead of signal().

       In the original Unix systems, when a handler that was established using
       signal()  was invoked by the delivery of a signal, the disposition of
       the signal would be reset to SIG_DFL, and the system did not block
       delivery of further instances of the signal.  System V also provides
       these semantics for signal().  This was bad because the signal might be
       delivered again before the handler had a chance to reestablish itself.
       Furthermore, rapid deliveries of the same signal could result in recur-
       sive invocations of the handler.

       BSD improved on this situation by changing the semantics of signal han-
       dling (but, unfortunately, silently changed the semantics when estab-
       lishing a handler with signal()).  On BSD, when a signal handler is
       invoked, the signal disposition is not reset, and further instances of
       the signal are blocked from being delivered while the handler is exe-
       cuting.

       The situation on Linux is as follows:

       * The kernel's signal() system call provides System V semantics.

       * By default, in glibc 2 and later, the signal() wrapper function does
         not invoke the kernel system call.  Instead, it calls sigaction(2)
         using flags that supply BSD semantics.  This default behavior is pro-
         vided as long as the _BSD_SOURCE feature test macro is defined.  By
         default, _BSD_SOURCE is defined; it is also implicitly defined if one
         defines _GNU_SOURCE, and can of course be explicitly defined.

         On glibc 2 and later, if the _BSD_SOURCE feature test macro is not
         defined, then signal() provides System V semantics.   (The default
         implicit definition of _BSD_SOURCE is not provided if one invokes
         gcc(1) in one of its standard modes (-std=xxx or  -ansi)  or defines
         various other feature test macros such as _POSIX_SOURCE,
         _XOPEN_SOURCE, or _SVID_SOURCE; see feature_test_macros(7).)

       * The signal() function in Linux libc4 and libc5 provide System V
         semantics.   If one on a libc5 system includes <bsd/signal.h> instead
         of <signal.h>, then signal() provides BSD semantics.

SEE ALSO
       kill(1), alarm(2), kill(2),  killpg(2),  pause(2),  sigaction(2),  sig-
       nalfd(2),  sigpending(2),  sigprocmask(2),  sigqueue(2), sigsuspend(2),
       bsd_signal(3),  raise(3),  siginterrupt(3),  sigsetops(3),   sigvec(3),
       sysv_signal(3), feature_test_macros(7), signal(7)

COLOPHON
       This page is part of release 3.22 of the Linux man-pages project.  A
       description of the project, and information about reporting bugs,  can
       be found at http://www.kernel.org/doc/man-pages/.



Linux                             2008-07-11                         SIGNAL(2)
SIGNAL(3P)                 POSIX Programmer's Manual                SIGNAL(3P)



PROLOG
       This manual page is part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ (consult the corresponding
       Linux manual page for details of Linux behavior), or the interface may
       not be implemented on Linux.

NAME
       signal - signal management

SYNOPSIS
       #include <signal.h>

       void (*signal(int sig, void (*func)(int)))(int);


DESCRIPTION
       Use of this function is unspecified in a multi-threaded process.

       The signal() function chooses one of three ways in which receipt of the
       signal number sig is to be subsequently handled. If the value of func
       is SIG_DFL, default handling for that signal shall occur. If the value
       of func is SIG_IGN, the signal shall be ignored. Otherwise, the appli-
       cation shall ensure that func points to a function to be called when
       that signal occurs. An invocation of such a function because of a sig-
       nal, or (recursively) of any further functions called by that invoca-
       tion  (other than functions in the standard library), is called a "sig-
       nal handler".

       When a signal occurs, and func points to a function, it is implementa-
       tion-defined whether the equivalent of a:


              signal(sig, SIG_DFL);

       is executed or the implementation prevents some implementation-defined
       set of signals (at least including sig) from occurring until the cur-
       rent signal handling has completed. (If the value of sig is SIGILL, the
       implementation may alternatively define that no action is taken.)  Next
       the equivalent of:


              (*func)(sig);

       is executed. If and when the function returns, if the value of sig was
       SIGFPE, SIGILL, or SIGSEGV or any other implementation-defined value
       corresponding to a computational exception, the behavior is undefined.
       Otherwise, the program shall resume execution at the point it was
       interrupted. If the signal occurs as the result of calling the abort(),
       raise(),   kill(), pthread_kill(), or sigqueue()  function, the signal
       handler shall not call the raise() function.

       If the signal occurs other than as the result of calling abort(),
       raise(),   kill(), pthread_kill(),  or sigqueue(),   the behavior is
       undefined if the signal handler refers to any object with static stor-
       age duration other than by assigning a value to an object declared as
       volatile sig_atomic_t,  or if the signal handler calls any function in
       the standard library other than one of the functions listed in Signal
       Concepts  .  Furthermore,  if such a call fails, the value of errno is
       unspecified.

       At program start-up, the equivalent of:


              signal(sig, SIG_IGN);

       is executed for some signals, and the equivalent of:


              signal(sig, SIG_DFL);

       is executed for all other signals  (see exec).

RETURN VALUE
       If the request can be honored, signal() shall return the value of func
       for the most recent call to signal() for the specified signal sig. Oth-
       erwise, SIG_ERR shall be returned and a positive value shall be stored
       in errno.

ERRORS
       The signal() function shall fail if:

       EINVAL The sig argument is not a valid signal number or an attempt is
              made to catch a signal that cannot be caught or ignore a signal
              that cannot be ignored.


       The signal() function may fail if:

       EINVAL An attempt was made to set the action to SIG_DFL for a signal
              that cannot be caught or ignored (or both).


       The following sections are informative.

EXAMPLES
       None.

APPLICATION USAGE
       The sigaction() function provides a more comprehensive and reliable
       mechanism for controlling signals; new applications should use sigac-
       tion() rather than signal().

RATIONALE
       None.

FUTURE DIRECTIONS
       None.

SEE ALSO
       Signal Concepts, exec(), pause(), sigaction(), sigsuspend(),  waitid(),
       the Base Definitions volume of IEEE Std 1003.1-2001, <signal.h>

COPYRIGHT
       Portions of this text are reprinted and reproduced in electronic form
       from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology
       --  Portable Operating System Interface (POSIX), The Open Group Base
       Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of
       Electrical and Electronics Engineers, Inc and The Open Group. In the
       event of any discrepancy between this version and the original IEEE and
       The Open Group Standard, the original IEEE and The Open Group Standard
       is the referee document. The original Standard can be obtained online
       at http://www.opengroup.org/unix/online.html .



IEEE/The Open Group                  2003                           SIGNAL(3P)
SIGNAL(7)                  Linux Programmer's Manual                 SIGNAL(7)



NAME
       signal - overview of signals

DESCRIPTION
       Linux supports both POSIX reliable signals (hereinafter "standard sig-
       nals") and POSIX real-time signals.

   Signal Dispositions
       Each signal has a current disposition, which determines how the process
       behaves when it is delivered the signal.

       The entries in the "Action"  column of the tables below specify the
       default disposition for each signal, as follows:

       Term Default action is to terminate the process.

       Ign    Default action is to ignore the signal.

       Core Default action is to terminate the process and dump core  (see
              core(5)).

       Stop Default action is to stop the process.

       Cont Default action is to continue the process if it is currently
              stopped.

       A process can change the disposition of a signal using sigaction(2)  or
       (less portably)  signal(2).   Using these system calls, a process can
       elect one of the following behaviors to occur on delivery of the sig-
       nal: perform the default action; ignore the signal; or catch the signal
       with a signal handler, a programmer-defined function that is automati-
       cally invoked when the signal is delivered.  (By default, the signal
       handler is invoked on the normal process stack.   It is possible to
       arrange that the signal handler uses an alternate stack; see sigalt-
       stack(2) for a discussion of how to do this and when it might be use-
       ful.)

       The signal disposition is a per-process attribute: in a multithreaded
       application, the disposition of a particular signal is the same for all
       threads.

       A child created via fork(2) inherits a copy of its parent's signal dis-
       positions.  During an execve(2), the dispositions of handled signals
       are reset to the default; the dispositions of ignored signals are left
       unchanged.

   Sending a Signal
       The following system calls and library functions allow the caller to
       send a signal:

       raise(3)        Sends a signal to the calling thread.

       kill(2)         Sends a signal to a specified process, to all members
                       of a specified process group, or to all processes on
                       the system.

       killpg(2)       Sends a signal to all of the members of a specified
                       process group.

       pthread_kill(3) Sends a signal to a specified POSIX thread in the same
                       process as the caller.

       tgkill(2)       Sends a signal to a specified thread within a specific
                       process.  (This is the system call used to implement
                       pthread_kill(3).)

       sigqueue(2)     Sends a real-time signal with accompanying data to a
                       specified process.

   Waiting for a Signal to be Caught
       The following system calls suspend execution of the calling process or
       thread until a signal is caught (or an unhandled signal terminates the
       process):

       pause(2)        Suspends execution until any signal is caught.

       sigsuspend(2)   Temporarily changes the signal mask (see below)  and
                       suspends execution until one of the unmasked signals is
                       caught.

   Synchronously Accepting a Signal
       Rather than asynchronously catching a signal via a signal handler,  it
       is possible to synchronously accept the signal, that is, to block exe-
       cution until the signal is delivered, at which point the kernel returns
       information about the signal to the caller.  There are two general ways
       to do this:

       * sigwaitinfo(2), sigtimedwait(2),  and sigwait(3)  suspend execution
         until one of the signals in a specified set is delivered.  Each of
         these calls returns information about the delivered signal.

       * signalfd(2) returns a file descriptor that can be used to read infor-
         mation about signals that are delivered to the caller.  Each read(2)
         from this file descriptor blocks until one of the signals in the set
         specified in the signalfd(2) call is delivered to the caller.  The
         buffer returned by read(2) contains a structure describing the sig-
         nal.

   Signal Mask and Pending Signals
       A signal may be blocked,  which means that it will not be delivered
       until it is later unblocked.  Between the time when it is generated and
       when it is delivered a signal is said to be pending.

       Each thread in a process has an independent signal mask, which indi-
       cates the set of signals that the thread is currently blocking.   A
       thread can manipulate its signal mask using pthread_sigmask(3).  In a
       traditional single-threaded application, sigprocmask(2) can be used to
       manipulate the signal mask.

       A child created via fork(2)  inherits a copy of its parent's signal
       mask; the signal mask is preserved across execve(2).

       A signal may be generated (and thus pending) for a process as a whole
       (e.g., when sent using kill(2)) or for a specific thread (e.g., certain
       signals, such as SIGSEGV and SIGFPE, generated as a consequence of exe-
       cuting a specific machine-language instruction are thread directed, as
       are signals targeted at a specific thread using pthread_kill(3)).   A
       process-directed signal may be delivered to any one of the threads that
       does not currently have the signal blocked.  If more than one of the
       threads has the signal unblocked, then the kernel chooses an arbitrary
       thread to which to deliver the signal.

       A thread can obtain the set of signals that it currently has pending
       using sigpending(2).  This set will consist of the union of the set of
       pending process-directed signals and the set of signals pending for the
       calling thread.

       A child created via fork(2) initially has an empty pending signal set;
       the pending signal set is preserved across an execve(2).

   Standard Signals
       Linux supports the standard signals listed below.  Several signal num-
       bers are architecture-dependent,  as indicated in the "Value" column.
       (Where three values are given, the first one is usually valid for alpha
       and sparc,  the middle one for ix86, ia64, ppc, s390, arm and sh, and
       the last one for mips.  A - denotes that a signal is absent on the cor-
       responding architecture.)

       First the signals described in the original POSIX.1-1990 standard.

       Signal     Value     Action Comment
       ----------------------------------------------------------------------
       SIGHUP        1       Term    Hangup detected on controlling terminal
                                     or death of controlling process
       SIGINT        2       Term    Interrupt from keyboard
       SIGQUIT       3       Core    Quit from keyboard
       SIGILL        4       Core    Illegal Instruction
       SIGABRT       6       Core    Abort signal from abort(3)
       SIGFPE        8       Core    Floating point exception
       SIGKILL       9       Term    Kill signal
       SIGSEGV      11       Core    Invalid memory reference
       SIGPIPE      13       Term    Broken pipe: write to pipe with no
                                     readers
       SIGALRM      14       Term    Timer signal from alarm(2)
       SIGTERM      15       Term    Termination signal
       SIGUSR1 30,10,16    Term    User-defined signal 1
       SIGUSR2 31,12,17    Term    User-defined signal 2
       SIGCHLD 20,17,18    Ign     Child stopped or terminated
       SIGCONT 19,18,25    Cont    Continue if stopped
       SIGSTOP 17,19,23    Stop    Stop process
       SIGTSTP 18,20,24    Stop    Stop typed at tty
       SIGTTIN 21,21,26    Stop    tty input for background process
       SIGTTOU 22,22,27    Stop    tty output for background process

       The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.

       Next the signals not in the POSIX.1-1990 standard but described in
       SUSv2 and POSIX.1-2001.

       Signal       Value     Action Comment
       --------------------------------------------------------------------
       SIGBUS      10,7,10     Core    Bus error (bad memory access)
       SIGPOLL                 Term    Pollable event (Sys V).
                                       Synonym for SIGIO
       SIGPROF     27,27,29    Term    Profiling timer expired
       SIGSYS      12,-,12     Core    Bad argument to routine (SVr4)
       SIGTRAP        5        Core    Trace/breakpoint trap
       SIGURG      16,23,21    Ign     Urgent condition on socket (4.2BSD)
       SIGVTALRM 26,26,28    Term    Virtual alarm clock (4.2BSD)
       SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2BSD)
       SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2BSD)

       Up to and including Linux 2.2, the default behavior for SIGSYS, SIGX-
       CPU, SIGXFSZ, and (on architectures other than SPARC and MIPS)  SIGBUS
       was to terminate the process (without a core dump).  (On some other
       Unix systems the default action for SIGXCPU and SIGXFSZ is to terminate
       the process without a core dump.)   Linux 2.4 conforms to the
       POSIX.1-2001 requirements for these signals,  terminating the process
       with a core dump.

       Next various other signals.

       Signal       Value     Action Comment

       --------------------------------------------------------------------
       SIGIOT         6        Core    IOT trap. A synonym for SIGABRT
       SIGEMT       7,-,7      Term
       SIGSTKFLT    -,16,-     Term    Stack fault on coprocessor (unused)
       SIGIO       23,29,22    Term    I/O now possible (4.2BSD)
       SIGCLD       -,-,18     Ign     A synonym for SIGCHLD
       SIGPWR      29,30,19    Term    Power failure (System V)
       SIGINFO      29,-,-             A synonym for SIGPWR
       SIGLOST      -,-,-      Term    File lock lost
       SIGWINCH    28,28,20    Ign     Window resize signal (4.3BSD, Sun)
       SIGUNUSED    -,31,-     Term    Unused signal (will be SIGSYS)

       (Signal 29 is SIGINFO / SIGPWR on an alpha but SIGLOST on a sparc.)

       SIGEMT is not specified in POSIX.1-2001, but nevertheless appears on
       most other Unix systems, where its default action is typically to ter-
       minate the process with a core dump.

       SIGPWR (which is not specified in POSIX.1-2001) is typically ignored by
       default on those other Unix systems where it appears.

       SIGIO (which is not specified in POSIX.1-2001) is ignored by default on
       several other Unix systems.

   Real-time Signals
       Linux supports real-time signals as originally defined in the POSIX.1b
       real-time extensions (and now included in POSIX.1-2001).  The range of
       supported real-time signals is defined by the macros SIGRTMIN and
       SIGRTMAX.  POSIX.1-2001 requires that an implementation support at
       least _POSIX_RTSIG_MAX (8) real-time signals.

       The Linux kernel supports a range of 32 different real-time signals,
       numbered 33 to 64.  However, the glibc POSIX threads implementation
       internally uses two  (for NPTL) or three (for LinuxThreads) real-time
       signals (see pthreads(7)), and adjusts the value of SIGRTMIN suitably
       (to 34 or 35).  Because the range of available real-time signals varies
       according to the glibc threading implementation (and this variation can
       occur at run time according to the available kernel and glibc), and
       indeed the range of real-time signals varies across Unix systems,  pro-
       grams should never refer to real-time signals using hard-coded numbers,
       but instead should always refer to real-time signals using the notation
       SIGRTMIN+n, and include suitable (run-time) checks that SIGRTMIN+n does
       not exceed SIGRTMAX.

       Unlike standard signals, real-time signals have no predefined meanings:
       the entire set of real-time signals can be used for application-defined
       purposes.  (Note, however, that the LinuxThreads implementation uses
       the first three real-time signals.)

       The default action for an unhandled real-time signal is to terminate
       the receiving process.

       Real-time signals are distinguished by the following:

       1.  Multiple instances of real-time signals can be queued.   By con-
           trast,  if multiple instances of a standard signal are delivered
           while that signal is currently blocked, then only one instance is
           queued.

       2.  If the signal is sent using sigqueue(2), an accompanying value
           (either an integer or a pointer) can be sent with the signal.   If
           the receiving process establishes a handler for this signal using
           the SA_SIGINFO flag to sigaction(2) then it can obtain this data
           via the si_value field of the siginfo_t structure passed as the
           second argument to the handler.  Furthermore, the si_pid and si_uid
           fields of this structure can be used to obtain the PID and real
           user ID of the process sending the signal.

       3.  Real-time signals are delivered in a guaranteed order.   Multiple
           real-time signals of the same type are delivered in the order they
           were sent.  If different real-time signals are sent to a process,
           they are delivered starting with the lowest-numbered signal.
           (I.e., low-numbered signals have highest priority.)   By contrast,
           if multiple standard signals are pending for a process, the order
           in which they are delivered is unspecified.

       If both standard and real-time signals are pending for a process, POSIX
       leaves it unspecified which is delivered first.  Linux, like many other
       implementations, gives priority to standard signals in this case.

       According to POSIX,  an implementation should permit at least
       _POSIX_SIGQUEUE_MAX  (32)  real-time signals to be queued to a process.
       However, Linux does things differently.  In kernels up to and including
       2.6.7,  Linux imposes a system-wide limit on the number of queued real-
       time signals for all processes.  This limit can be viewed and (with
       privilege)  changed via the /proc/sys/kernel/rtsig-max file.  A related
       file, /proc/sys/kernel/rtsig-nr, can be used to find out how many real-
       time signals are currently queued.  In Linux 2.6.8, these /proc inter-
       faces were replaced by the RLIMIT_SIGPENDING resource limit,  which
       specifies a per-user limit for queued signals; see setrlimit(2) for
       further details.

   Async-signal-safe functions
       A signal handling routine established by sigaction(2) or signal(2) must
       be very careful, since processing elsewhere may be interrupted at some
       arbitrary point in the execution of the program.  POSIX has the concept
       of  "safe function".  If a signal interrupts the execution of an unsafe
       function, and handler calls an unsafe function, then the behavior of
       the program is undefined.

       POSIX.1-2004  (also known as POSIX.1-2001 Technical Corrigendum 2)
       requires an implementation to guarantee that the following functions
       can be safely called inside a signal handler:

           _Exit()
           _exit()
           abort()
           accept()
           access()
           aio_error()
           aio_return()
           aio_suspend()
           alarm()
           bind()
           cfgetispeed()
           cfgetospeed()
           cfsetispeed()
           cfsetospeed()
           chdir()
           chmod()
           chown()
           clock_gettime()
           close()
           connect()
           creat()
           dup()
           dup2()
           execle()
           execve()
           fchmod()
           fchown()
           fcntl()
           fdatasync()
           fork()
           fpathconf()
           fstat()
           fsync()
           ftruncate()
           getegid()
           geteuid()
           getgid()
           getgroups()
           getpeername()
           getpgrp()
           getpid()
           getppid()
           getsockname()
           getsockopt()
           getuid()
           kill()
           link()
           listen()
           lseek()
           lstat()
           mkdir()
           mkfifo()
           open()
           pathconf()
           pause()
           pipe()
           poll()
           posix_trace_event()
           pselect()
           raise()
           read()
           readlink()
           recv()
           recvfrom()
           recvmsg()
           rename()
           rmdir()
           select()
           sem_post()
           send()
           sendmsg()
           sendto()
           setgid()
           setpgid()
           setsid()
           setsockopt()
           setuid()
           shutdown()
           sigaction()
           sigaddset()
           sigdelset()
           sigemptyset()
           sigfillset()
           sigismember()
           signal()
           sigpause()
           sigpending()
           sigprocmask()
           sigqueue()
           sigset()
           sigsuspend()
           sleep()
           sockatmark()
           socket()
           socketpair()
           stat()
           symlink()
           sysconf()
           tcdrain()
           tcflow()
           tcflush()
           tcgetattr()
           tcgetpgrp()
           tcsendbreak()
           tcsetattr()
           tcsetpgrp()
           time()
           timer_getoverrun()
           timer_gettime()
           timer_settime()
           times()
           umask()
           uname()
           unlink()
           utime()
           wait()
           waitpid()
           write()

       POSIX.1-2008 removes fpathconf(),  pathconf(), and sysconf() from the
       above list, and adds the following functions:

           execl()
           execv()
           faccessat()
           fchmodat()
           fchownat()
           fexecve()
           fstatat()
           futimens()
           linkat()
           mkdirat()
           mkfifoat()
           mknod()
           mknodat()
           openat()
           readlinkat()
           renameat()
           symlinkat()
           unlinkat()
           utimensat()
           utimes()

   Interruption of System Calls and Library Functions by Signal Handlers
       If a signal handler is invoked while a system call or library function
       call is blocked, then either:

       * the call is automatically restarted after the signal handler returns;
         or

       * the call fails with the error EINTR.

       Which of these two behaviors occurs depends on the interface and
       whether or not the signal handler was established using the SA_RESTART
       flag (see sigaction(2)).  The details vary across Unix systems;  below,
       the details for Linux.

       If a blocked call to one of the following interfaces is interrupted by
       a signal handler, then the call will be automatically restarted after
       the signal handler returns if the SA_RESTART flag was used; otherwise
       the call will fail with the error EINTR:

           * read(2), readv(2), write(2), writev(2),  and ioctl(2)  calls on
             "slow"  devices.   A  "slow" device is one where the I/O call may
             block for an indefinite time, for example, a terminal,  pipe,  or
             socket.   (A disk is not a slow device according to this defini-
             tion.)  If an I/O call on a slow device has already transferred
             some data by the time it is interrupted by a signal handler, then
             the call will return a success status (normally,  the number of
             bytes transferred).

           * open(2),  if it can block (e.g.,  when opening a FIFO; see
             fifo(7)).

           * wait(2), wait3(2), wait4(2), waitid(2), and waitpid(2).

           * Socket interfaces: accept(2), connect(2),  recv(2),  recvfrom(2),
             recvmsg(2),  send(2), sendto(2), and sendmsg(2), unless a timeout
             has been set on the socket (see below).

           * File locking interfaces: flock(2) and fcntl(2) F_SETLKW.

           * POSIX message queue interfaces:   mq_receive(3),   mq_time-
             dreceive(3), mq_send(3), and mq_timedsend(3).

           * futex(2)  FUTEX_WAIT  (since Linux 2.6.22;  beforehand,  always
             failed with EINTR).

           * POSIX semaphore interfaces:  sem_wait(3)  and sem_timedwait(3)
             (since Linux 2.6.22; beforehand, always failed with EINTR).

       The following interfaces are never restarted after being interrupted by
       a signal handler, regardless of the use of SA_RESTART; they always fail
       with the error EINTR when interrupted by a signal handler:

           * Socket interfaces,  when a timeout has been set on the socket
             using setsockopt(2):  accept(2),   recv(2),   recvfrom(2),   and
             recvmsg(2), if a receive timeout (SO_RCVTIMEO) has been set; con-
             nect(2), send(2), sendto(2), and sendmsg(2), if a send timeout
             (SO_SNDTIMEO) has been set.

           * Interfaces used to wait for signals: pause(2), sigsuspend(2),
             sigtimedwait(2), and sigwaitinfo(2).

           * File descriptor multiplexing    interfaces:    epoll_wait(2),
             epoll_pwait(2), poll(2), ppoll(2), select(2), and pselect(2).

           * System V IPC interfaces: msgrcv(2), msgsnd(2), semop(2), and sem-
             timedop(2).

           * Sleep interfaces:   clock_nanosleep(2),    nanosleep(2),    and
             usleep(3).

           * read(2) from an inotify(7) file descriptor.

           * io_getevents(2).

       The sleep(3) function is also never restarted if interrupted by a han-
       dler, but gives a success return: the number of seconds remaining to
       sleep.

   Interruption of System Calls and Library Functions by Stop Signals
       On Linux,  even in the absence of signal handlers, certain blocking
       interfaces can fail with the error EINTR after the process is stopped
       by one of the stop signals and then resumed via SIGCONT.  This behavior
       is not sanctioned by POSIX.1, and doesn't occur on other systems.

       The Linux interfaces that display this behavior are:

           * Socket interfaces, when a timeout has been set on the socket
             using setsockopt(2):   accept(2),   recv(2),  recvfrom(2),  and
             recvmsg(2), if a receive timeout (SO_RCVTIMEO) has been set; con-
             nect(2),  send(2),  sendto(2),  and sendmsg(2), if a send timeout
             (SO_SNDTIMEO) has been set.

           * epoll_wait(2), epoll_pwait(2).

           * semop(2), semtimedop(2).

           * sigtimedwait(2), sigwaitinfo(2).

           * read(2) from an inotify(7) file descriptor.

           * Linux 2.6.21 and earlier: futex(2) FUTEX_WAIT,  sem_timedwait(3),
             sem_wait(3).

           * Linux 2.6.8 and earlier: msgrcv(2), msgsnd(2).

           * Linux 2.4 and earlier: nanosleep(2).

CONFORMING TO
       POSIX.1, except as noted.

BUGS
       SIGIO and SIGLOST have the same value.  The latter is commented out in
       the kernel source, but the build process of some software still thinks
       that signal 29 is SIGLOST.

SEE ALSO
       kill(1),  getrlimit(2), kill(2), killpg(2), setitimer(2), setrlimit(2),
       sgetmask(2), sigaction(2), sigaltstack(2), signal(2), signalfd(2), sig-
       pending(2), sigprocmask(2), sigqueue(2), sigsuspend(2), sigwaitinfo(2),
       abort(3), bsd_signal(3), longjmp(3), raise(3), sigset(3), sigsetops(3),
       sigvec(3),  sigwait(3), strsignal(3), sysv_signal(3), core(5), proc(5),
       pthreads(7)

COLOPHON
       This page is part of release 3.22 of the Linux man-pages project.   A
       description of the project, and information about reporting bugs, can
       be found at http://www.kernel.org/doc/man-pages/.



Linux                             2008-10-15                         SIGNAL(7)
